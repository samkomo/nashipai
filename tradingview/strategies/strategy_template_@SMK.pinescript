// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© skarumba

//@version=5
strategy("Strategy Template @SMK", overlay = true, pyramiding=1,initial_capital = 10000, default_qty_type= strategy.percent_of_equity, default_qty_value = 100, calc_on_order_fills=false, slippage=0,commission_type=strategy.commission.percent,commission_value=0.075)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
// â€”â€”â€”â€”â€”â€” ToolTips
TText_source_    = 'ð„ð±ð­ðžð«ð§ðšð¥â€‚ð’ð¨ð®ð«ðœðžâ€‚âž–â€ŠHere you must select your Indicator, having previously connected the "Connector" to it.\nIf the "Close" option is selected then you can test the backtest on regular MA crosses EMA 200 and EMA 50.'
TTreversesignal  = 'ð–ðšð¢ð­â€‚ð„ð§ðâ€‚ðƒðžðšð¥â€‚âž– Enable/Disable waiting for a trade to close at Stop Loss/Take Profit. Until the trade closes on the Stop Loss or Take Profit, no new trade will open. \n'
                 + 'ð‘ðžð¯ðžð«ð¬ðžâ€‚ðƒðžðšð¥ð¬â€‚âž– If true strategy will go in the opposite direction from the signal.'
TTreOpenDeal     = 'ð‘ðžð„ð§ð­ð«ð²â€‚ðƒðžðšð¥â€‚âž– If true trade was long and  SL/TP was reached then go long again and vice versa. \n'
                 + 'ð‘ðžðŽð©ðžð§â€‚ðƒðžðšð¥â€‚âž– If true and Wait End Deal is false then in case you are in a Long position and a new signal to Long, you will reEnter a new Long position and vice versa for Shorts.'
TTslType         = 'ð…ðˆð—ð„ðƒâ€‚ï¼…â€‚âž– Fixed SL/TP in percent. \n'
                 + 'ð…ðˆð—ð„ðƒâ€‚ï¼„â€‚âž– Fixed SL/TP in cash. \n'
                 + 'ð“ð‘ð€ðˆð‹ðˆðð†â€‚âž– Trailing stop in ï¼… like on exchanges. Regulated by the "ð—§ð—¿ð—®ð—¶ð—¹ð—¶ð—»ð—´â€‚ï¼…" parameter. \n'
                 + 'ð…ð€ð’ð“â€‚ð“ð‘ð€ðˆð‹â€‚âž– If in a long, it immediately follows the price when it rises otherwise it stands still. Vice versa for shorts. Regulated by the "ð—§ð—¿ð—®ð—¶ð—¹ð—¶ð—»ð—´â€‚ï¼…" parameter. \n'
                 + 'ð€ð“ð‘â€‚âž– Fixed TP/SL depending on the current ATR. It is regulated by the "ð—”ð—§ð—¥â€‚ð—£ð—²ð—¿ð—¶ð—¼ð—±" | "ð— ð˜‚ð—¹ð˜ð—¶ð—½ð—¹ð—¶ð—²ð—¿" parameters. \n'
                 + 'ð—”ð—§ð—¥â€‚ð“ð‘ð€ðˆð‹â€‚âž– Trailing Stop calculated on the basis of the ATR. It is regulated by the "ð—”ð—§ð—¥â€‚ð—£ð—²ð—¿ð—¶ð—¼ð—±" | "ð— ð˜‚ð—¹ð˜ð—¶ð—½ð—¹ð—¶ð—²ð—¿" parameters. \n'
                 + 'ð—¥:ð—¥â€‚âž– Risk Reward sets the TP depending on the size of the SL. For example, if SL is ï¼„100, and R:R = 2, then the TP is ï¼„200. \n'
                 + 'ð‡ð‡â€‚/â€‚ð‹ð‹â€‚âž– Searches for the last Extremum (High/Low) for the specified number of bars and sets a fixed Take. \n'
                 + 'ð‹ðŽâ€‚/â€‚ð‡ðˆâ€‚âž– Sets the SL for High/Low candles. "ð—Ÿð—¢/ð—›ð—œ" = 1 Sets the SL for the last High/Low. \n'
                 + 'ðŒð€â€‚âž– Movieng Average SL. A very diverse type of SL.'



// ***************************************************
// Strategy - B-Xtrender
// ***************************************************

short_l1 = input(5, title='Short - L1')
short_l2 = input(20, title='Short - L2')
short_l3 = input(15, title='Short - L3')

long_l1 = input(20, title='Long - L1')
long_l2 = input(15, title='Long - L2')

shortTermXtrender = ta.rsi(ta.ema(close, short_l1) - ta.ema(close, short_l2), short_l3) - 50
longTermXtrender = ta.rsi(ta.ema(close, long_l1), long_l2) - 50

shortXtrenderCol = shortTermXtrender > 0 ? shortTermXtrender > shortTermXtrender[1] ? color.lime : #228B22 : shortTermXtrender > shortTermXtrender[1] ? color.red : #8B0000
// plot(shortTermXtrender, color=shortXtrenderCol, style=plot.style_columns, linewidth=1, title='B-Xtrender Osc. - Histogram', transp=50)

t3(src, len) =>
    xe1_1 = ta.ema(src, len)
    xe2_1 = ta.ema(xe1_1, len)
    xe3_1 = ta.ema(xe2_1, len)
    xe4_1 = ta.ema(xe3_1, len)
    xe5_1 = ta.ema(xe4_1, len)
    xe6_1 = ta.ema(xe5_1, len)
    b_1 = 0.7
    c1_1 = -b_1 * b_1 * b_1
    c2_1 = 3 * b_1 * b_1 + 3 * b_1 * b_1 * b_1
    c3_1 = -6 * b_1 * b_1 - 3 * b_1 - 3 * b_1 * b_1 * b_1
    c4_1 = 1 + 3 * b_1 + b_1 * b_1 * b_1 + 3 * b_1 * b_1
    nT3Average_1 = c1_1 * xe6_1 + c2_1 * xe5_1 + c3_1 * xe4_1 + c4_1 * xe3_1
    nT3Average_1

maShortTermXtrender = t3(shortTermXtrender, 5)

colShortTermXtrender = maShortTermXtrender > maShortTermXtrender[1] ? color.lime : color.red
// plot(maShortTermXtrender, color=color.new(#000000, 0), style=plot.style_line, linewidth=5, title='B-Xtrender Shadow')
// plot(maShortTermXtrender, color=colShortTermXtrender, style=plot.style_line, linewidth=3, title='B-Xtrender Color ')

// plotshape(maShortTermXtrender > maShortTermXtrender[1] and maShortTermXtrender[1] < maShortTermXtrender[2] ? maShortTermXtrender : na, location=location.absolute, style=shape.circle, color=color.new(color.lime, 10), size=size.tiny)
// plotshape(maShortTermXtrender < maShortTermXtrender[1] and maShortTermXtrender[1] > maShortTermXtrender[2] ? maShortTermXtrender : na, location=location.absolute, style=shape.circle, color=color.new(color.red, 10), size=size.tiny)

longXtrenderCol = longTermXtrender > 0 ? longTermXtrender > longTermXtrender[1] ? color.lime : #228B22 : longTermXtrender > longTermXtrender[1] ? color.red : #8B0000
macollongXtrenderCol = longTermXtrender > longTermXtrender[1] ? color.lime : color.red
// plot(longTermXtrender, color=longXtrenderCol, style=plot.style_histogram, linewidth=2, title='B-Xtrender Trend - Histogram', transp=80)

// plot(longTermXtrender, color=color.new(#000000, 80), style=plot.style_line, linewidth=5, title='B-Xtrender Trend - Line')
// plot(longTermXtrender, color=macollongXtrenderCol, style=plot.style_line, linewidth=3, title='B-Xtrender Trend - Line', transp=80)


// Entry Conditions
// Long Entry Signal
validLongEntry = maShortTermXtrender > maShortTermXtrender[1] and maShortTermXtrender[1] < maShortTermXtrender[2]
longEntrySignal = ta.crossover(maShortTermXtrender, maShortTermXtrender[1]) and longTermXtrender > 0 and shortTermXtrender > 0 and validLongEntry

// Short Entry Signal
validShortEntry = maShortTermXtrender < maShortTermXtrender[1] and maShortTermXtrender[1] > maShortTermXtrender[2]
shortEntrySignal = ta.crossunder(maShortTermXtrender, maShortTermXtrender[1]) and longTermXtrender < 0 and shortTermXtrender < 0 and validShortEntry


// ***************************************************
// Filters
// ***************************************************
/// Time filter
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

grouptime             = 'Time Filters'
src_timezone          = input.string ('Exchange',      'Timezones: Src',        group=grouptime, inline='Timezone', options=['Exchange', 'UTC', 'America/Los_Angeles', 'America/Phoenix', 'America/Vancouver', 'America/El_Salvador', 'America/Bogota', 'America/Chicago', 'America/New_York', 'America/Toronto', 'America/Argentina/Buenos_Aires', 'America/Sao_Paulo', 'Etc/UTC', 'Europe/London', 'Europe/Berlin', 'Europe/Madrid', 'Europe/Paris', 'Europe/Warsaw', 'Europe/Athens', 'Europe/Moscow', 'Asia/Tehran', 'Asia/Dubai', 'Asia/Ashkhabad', 'Asia/Kolkata', 'Asia/Almaty', 'Asia/Bangkok', 'Asia/Hong_Kong', 'Asia/Shanghai', 'Asia/Singapore', 'Asia/Taipei', 'Asia/Seoul', 'Asia/Tokyo', 'Australia/ACT', 'Australia/Adelaide', 'Australia/Brisbane', 'Australia/Sydney', 'Pacific/Auckland', 'Pacific/Fakaofo', 'Pacific/Chatham', 'Pacific/Honolulu'])
dst_timezone          = input.string ('Exchange',      ' -> Dst',                 group=grouptime, inline='Timezone', options=['Exchange', 'UTC', 'America/Los_Angeles', 'America/Phoenix', 'America/Vancouver', 'America/El_Salvador', 'America/Bogota', 'America/Chicago', 'America/New_York', 'America/Toronto', 'America/Argentina/Buenos_Aires', 'America/Sao_Paulo', 'Etc/UTC', 'Europe/London', 'Europe/Berlin', 'Europe/Madrid', 'Europe/Paris', 'Europe/Warsaw', 'Europe/Athens', 'Europe/Moscow', 'Asia/Tehran', 'Asia/Dubai', 'Asia/Ashkhabad', 'Asia/Kolkata', 'Asia/Almaty', 'Asia/Bangkok', 'Asia/Hong_Kong', 'Asia/Shanghai', 'Asia/Singapore', 'Asia/Taipei', 'Asia/Seoul', 'Asia/Tokyo', 'Australia/ACT', 'Australia/Adelaide', 'Australia/Brisbane', 'Australia/Sydney', 'Pacific/Auckland', 'Pacific/Fakaofo', 'Pacific/Chatham', 'Pacific/Honolulu'], tooltip='The Src is the timezone to be used as a reference for the time settings. The Dst is the timezone to convert into (e.g. the charslPrice\' timezone)')

usefromDate           = input.bool   (true,            'Srart Fromâ€ƒ',           group=grouptime, inline='From Date')
fromDate              = input.time   (timestamp('01 Jan 2020 00:00'), '',       group=grouptime, inline='From Date')
usetoDate             = input.bool   (false,           'End Toâ€‚â€‚â€‚â€‚â€‚â€Šâ€„',         group=grouptime, inline='To Date')
toDate                = input.time   (timestamp('01 Jul 2025 00:00'), '',       group=grouptime, inline='To Date')

useSessionDay         = input.bool   (false,           'Select Session Days',   group=grouptime)
mon                   = input.bool   (true,            'Mon',                   group=grouptime, inline='Session Days')
tue                   = input.bool   (true,            'Tue',                   group=grouptime, inline='Session Days')
wed                   = input.bool   (true,            'Wed',                   group=grouptime, inline='Session Days')
thu                   = input.bool   (true,            'Thu',                   group=grouptime, inline='Session Days')
fri                   = input.bool   (true,            'Fri',                   group=grouptime, inline='Session Days')
sat                   = input.bool   (false,           'Sat',                   group=grouptime, inline='Session Days')
sun                   = input.bool   (false,           'Sun',                   group=grouptime, inline='Session Days')
useSessionStart       = input.bool   (false,           'Session Start',         group=grouptime, inline='Session Start')
sessionStartHour      = input.int    (12,              '',                      group=grouptime, inline='Session Start', minval=0, maxval=23, step=1)
sessionStartMinute    = input.int    (00,              ':',                     group=grouptime, inline='Session Start', minval=0, maxval=59, step=1, tooltip='Start time of the session.')
useSessionEnd         = input.bool   (false,           'Session Endâ€‚',          group=grouptime, inline='Session End')
sessionEndHour        = input.int    (20,              '',                      group=grouptime, inline='Session End', minval=0, maxval=23, step=1)
sessionEndMinute      = input.int    (00,              ':',                     group=grouptime, inline='Session End', minval=0, maxval=59, step=1, tooltip='End time of the session.')

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
ex_timezone(simple string tz) =>
    switch tz
        'Exchange' => syminfo.timezone
        => tz    

if_in_date_range(simple bool usefromDate, simple int fromDate, simple bool usetoDate, simple int toDate, simple string src_timezone = 'Exchange', simple string dst_timezone = 'Exchange', int t = time_close) =>
    var src_tz     = ex_timezone(src_timezone)
    var dst_tz     = ex_timezone(dst_timezone)
    var fromDateTz = timestamp(src_tz, year(fromDate, dst_tz), month(fromDate, dst_tz), dayofmonth(fromDate, dst_tz), hour(fromDate, dst_tz), minute(fromDate, dst_tz), second(fromDate, dst_tz))
    var toDateTz   = timestamp(src_tz, year(toDate, dst_tz), month(toDate, dst_tz), dayofmonth(toDate, dst_tz), hour(toDate, dst_tz), minute(toDate, dst_tz), second(toDate, dst_tz))
    (usefromDate ? t >= fromDateTz : true) and (usetoDate ? t < toDateTz : true)

if_in_session(simple bool useSessionStart, simple int sessionStartHour, simple int sessionStartMinute, simple bool useSessionEnd, simple int sessionEndHour, simple int sessionEndMinute, simple bool useSessionDay = false, simple bool mon = true, simple bool tue = true, simple bool wed = true, simple bool thu = true, simple bool fri = true, simple bool sat = false, simple bool sun = false, simple string src_timezone = 'Exchange', simple string dst_timezone = 'Exchange', int t = time_close) =>
    var one_day = 86400000
    var utc_tz  = 'UTC'
    var src_tz  = ex_timezone(src_timezone)
    var dst_tz  = ex_timezone(dst_timezone)
    start_hr    = sessionStartHour   + (hour(t, dst_tz)   - hour(t, src_tz))
    start_min   = sessionStartMinute + (minute(t, dst_tz) - minute(t, src_tz))
    end_hr      = sessionEndHour     + (hour(t, dst_tz)   - hour(t, src_tz))
    end_min     = sessionEndMinute   + (minute(t, dst_tz) - minute(t, src_tz))
    time_start_session   = timestamp(dst_tz, year(t, src_tz), month(t, src_tz), dayofmonth(t, src_tz), start_hr, start_min, second(t, src_tz))
    time_end_session     = timestamp(dst_tz, year(t, src_tz), month(t, src_tz), dayofmonth(t, src_tz), end_hr,   end_min,   second(t, src_tz))
    var bool isOvernight = time_start_session >= time_end_session
    // in overnight sessions increase end time by one day
    if (useSessionStart and useSessionEnd and isOvernight)
        time_end_session := time_end_session + one_day
    isSessionDay = switch dayofweek(t, src_tz)
        dayofweek.monday    => mon
        dayofweek.tuesday   => tue
        dayofweek.wednesday => wed
        dayofweek.thursday  => thu
        dayofweek.friday    => fri
        dayofweek.saturday  => sat
        dayofweek.sunday    => sun
        => false
    (useSessionDay ? isSessionDay : true) and (useSessionStart ? t >= time_start_session : true) and (useSessionEnd ? t < time_end_session : true)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
bool dateFilterApproval     = if_in_date_range(usefromDate, fromDate, usetoDate, toDate, src_timezone, dst_timezone)
bool sessionFilterApproval  = if_in_session(useSessionStart, sessionStartHour, sessionStartMinute, useSessionEnd, sessionEndHour, sessionEndMinute, useSessionDay, mon, tue, wed, thu, fri, sat, sun, src_timezone, dst_timezone)
bool timeFilterApproval     = dateFilterApproval and sessionFilterApproval

/// Signal filters
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

groupsignal           = 'ï¼³ignal Filters'
FilterType1           = input.bool   (false,           '1. ADX',                                           group=groupsignal, inline='FT1')
FilterType1Len        = input.int    (17,              '',                                                 group=groupsignal, inline='FT1', minval=1 )
FilterType1Smt        = input.int    (14,              '',                                                 group=groupsignal, inline='FT1', minval=1, maxval=50)
FilterType1Tresh      = input.int    (20,              '',                                                 group=groupsignal, inline='FT1', minval=1, maxval=50, tooltip='ADX Lenght, Smooth, Level. \nTrade If ADX < Level')
FilterType2           = input.bool   (false,           '2. MACD',                                          group=groupsignal, inline='FT2')
FilterType2Len1       = input.int    (12,              '',                                                 group=groupsignal, inline='FT2')
FilterType2Len2       = input.int    (26,              '',                                                 group=groupsignal, inline='FT2')
FilterType2Len3       = input.int    (9,               '',                                                 group=groupsignal, inline='FT2', tooltip='Fast Len, Slow Len, Smooth. \nLong Filter: MACD > 0\nShort Filter: MACD < 0')
FilterType3           = input.bool   (false,           '3. Bar direction=Trade direction',                 group=groupsignal, tooltip='Long filter: close>open\nShort Filter: close<open')
FilterType4           = input.bool   (false,           '4. Rising Volume',                                 group=groupsignal, tooltip='Long Filter: Volume Increasing\nShort Filter: Volume Decreasing')
FilterType5           = input.bool   (false,           '5. Rising/Falling MA',                             group=groupsignal, inline='FT5', tooltip='Long Filter: SMA is Rising\nShort Filter: SMA Falling \nRising/Falling - For N Bars')
FilterType5Len        = input.int    (50,              'Length',                                           group=groupsignal, inline='FT5', minval=2)
FilterType5Bars       = input.int    (1,               'Bars',                                             group=groupsignal, inline='FT5', minval=1)
FilterType6           = input.bool   (false,           '6. High/Low Filter',                               group=groupsignal, inline='FT6')
FilterType6Bars       = input.int    (10,              'Lookback',                                         group=groupsignal, inline='FT6', tooltip='If true then the signal bar must be the highest/lovest bar over X bars')
FilterType7           = input.bool   (false,           '7. Maximum close change (ï¼…) allowed on entry',    group=groupsignal, inline='FT7')
FilterType7IncPct     = input.float  (10.0,            '',                                                 group=groupsignal, inline='FT7', minval=0.0, step=0.5)
FilterType8           = input.bool   (false,           '8. Minimum close change (ï¼…) allowed on entry',    group=groupsignal, inline='FT8')
FilterType8IncPct     = input.float  (1.0,             '',                                                 group=groupsignal, inline='FT8', minval=0.0, step=0.5)
FilterType9           = input.bool   (false,           '9. RSI OS/OB',                                     group=groupsignal, inline='FT9')
FilterType9Len        = input.int    (20,              '',                                                 group=groupsignal, inline='FT9', minval=2)
FilterType9OS         = input.int    (25,              '',                                                 group=groupsignal, inline='FT9', minval=0, maxval=100)
FilterType9OB         = input.int    (75,              '',                                                 group=groupsignal, inline='FT9', minval=0, maxval=100, tooltip='RSI Length, OS Level, OB Level \nLong = RSI < OB\nShort = RSI > OS')
FilterType10          = input.bool   (false,           '10. MA',                                           group=groupsignal, inline='FT10')
FilterType10MAType    = input.string ('SMA',           '',                                                 group=groupsignal, inline='FT10', options=['ALMA', 'EMA', 'HMA', 'RMA', 'SMA', 'VWMA', 'WMA'])
FilterType10Len       = input.int    (200,             '',                                                 group=groupsignal, inline='FT10', minval=1, tooltip='MA Type, MA Source, MA Length\nLong = close > MA\nShort = close < MA')
FilterType11          = input.bool   (false,           '11. EMA Difference',                               group=groupsignal, inline='FT11')
FilterType11Len1      = input.int    (30,              '',                                                 group=groupsignal, inline='FT11')
FilterType11Len2      = input.int    (60,              '',                                                 group=groupsignal, inline='FT11', tooltip='Short EMA Length, Long EMA Length. \nLong Filter: EMA Difference > 0\nShort Filter: EMA Difference < 0')




MA(string _maType, float _maSource, simple int _maLength) =>
    float ma = switch _maType
        'ALMA' => ta.alma (_maSource, _maLength, 0.85, 6)
        'EMA'  => ta.ema  (_maSource, _maLength)
        'HMA'  => ta.hma  (_maSource, _maLength)
        'RMA'  => ta.rma  (_maSource, _maLength)
        'SMA'  => ta.sma  (_maSource, _maLength)
        'VWMA' => ta.vwma (_maSource, _maLength)
        'WMA'  => ta.wma  (_maSource, _maLength)

// â€”â€”â€”â€”â€”â€” Filter 1: ADX
[dip, dim, adx] = ta.dmi(FilterType1Len, FilterType1Smt)
Filter1Long     = FilterType1 ? adx < FilterType1Tresh : true
Filter1Short    = Filter1Long
// â€”â€”â€”â€”â€”â€” Filter 2: MACD Hist
_macdLine       = FilterType2 ? nz(MA('EMA', close, FilterType2Len1) - MA('EMA', close, FilterType2Len2)) : 0.
_macdSignal     = FilterType2 ? nz(MA('EMA', _macdLine, FilterType2Len3)) : 0.
_macdHist       = FilterType2 ? _macdLine - _macdSignal : 0.
Filter2Long     = FilterType2 ? _macdHist > 0 : true
Filter2Short    = FilterType2 ? _macdHist < 0 : true
// â€”â€”â€”â€”â€”â€” Filter 3: Bar direction
Filter3Long     = FilterType3 ? close > open : true
Filter3Short    = FilterType3 ? close < open : true
// â€”â€”â€”â€”â€”â€” Filter 4: Rising volume
Filter4Long     = FilterType4 ? ta.rising(volume, 1) : true
Filter4Short    = Filter4Long
// â€”â€”â€”â€”â€”â€” Filter 5: Rising/Falling MA
Filter5Ma       = FilterType5 ? nz(MA('SMA', close, FilterType5Len)) : 0
Filter5Long     = FilterType5 ? ta.rising(Filter5Ma, FilterType5Bars) : true
Filter5Short    = FilterType5 ? ta.falling(Filter5Ma, FilterType5Bars) : true
// â€”â€”â€”â€”â€”â€” Filter 6: Check high & close filter
Filter6Long     = FilterType6 ? high >= ta.highest(high, FilterType6Bars) : true
Filter6Short    = FilterType6 ? low <= ta.lowest(low, FilterType6Bars) : true
// â€”â€”â€”â€”â€”â€” Filter 7: Maximum delta with previous close allowed at entry
Filter7Long     = FilterType7 ? close < close[1] * (1 + FilterType7IncPct / 100) : true
Filter7Short    = FilterType7 ? close > close[1] * (1 - FilterType7IncPct / 100) : true
// â€”â€”â€”â€”â€”â€” Filter 8: Minimum delta with previous close allowed at entry
Filter8Long     = FilterType8 ? close > close[1] * (1 + FilterType8IncPct / 100) : true
Filter8Short    = FilterType8 ? close < close[1] * (1 - FilterType8IncPct / 100) : true
// â€”â€”â€”â€”â€”â€” Filter 9: RSI OS/OB
Rsi             = FilterType9 ? ta.rsi(close, FilterType9Len) : 0
RsiOB           = Rsi > FilterType9OB
RsiOS           = Rsi < FilterType9OS
Filter9Long     = FilterType9 ? not RsiOB : true
Filter9Short    = FilterType9 ? not RsiOS : true
// â€”â€”â€”â€”â€”â€” Filter 10: Moving Average
Filter10Ma      = FilterType10 ? MA(FilterType10MAType, close, FilterType10Len) : 0.
Filter10Long    = FilterType10 ? close > Filter10Ma : true
Filter10Short   = FilterType10 ? close < Filter10Ma : true
// â€”â€”â€”â€”â€”â€” Filter 11: EMA Difference
dif_1 = ta.ema(close,FilterType11Len1)
dif_2 = ta.ema(close, FilterType11Len2)
dif3 = dif_1 - dif_2
Filter11Long    = FilterType11 ? dif3 > 0 : true
Filter11Short   = FilterType11 ? dif3 < 0 : true
// â€”â€”â€”â€”â€”â€” Assemble Filters
FilterLongOK    = Filter1Long and Filter2Long and Filter3Long and Filter4Long and Filter5Long
 and Filter6Long and Filter7Long and Filter8Long and Filter9Long and Filter10Long and Filter11Long
FilterShortOK   = Filter1Short and Filter2Short and Filter3Short and Filter4Short and Filter5Short
 and Filter6Short and Filter7Short and Filter8Short and Filter9Short and Filter10Short and Filter11Short



// ***************************************************
// ï¼­ï¼¡ï¼©ï¼®â€‚â€‚ï¼³ï¼¥ï¼´ï¼´ï¼©ï¼®ï¼§ï¼³
// ***************************************************
groupset         = 'Risk Management'
tpType           = input.string ('R:R',       'Take Profit Type',           group=groupset, inline='type', options=['None', 'FIXED ï¼…', 'FIXED ï¼„', 'ATR', 'R:R', 'HH / LL']) 
slType           = input.string ('ATR',       'Stop Loss Type',             group=groupset, inline='type', options=['None', 'FIXED ï¼…', 'FIXED ï¼„', 'TRAILING', 'FAST TRAIL', 'ATR', 'ATR TRAIL', 'LO / HI', 'MA'], tooltip=TTslType)
percentTP    = input.float  (4.5,             'â€‚Profit ï¼…â€‚â€‚â€‚â€‚',            group=groupset, inline='fix', minval=0.1, step=0.1)
percentSL    = input.float  (1.5,             'â€‚Stop ï¼…â€‚â€‚',                group=groupset, inline='fix', minval=0.1, step=0.1)
moneyTP      = input.float  (333,             'â€‚Profit ï¼„â€‚â€‚â€‚â€‚',            group=groupset, inline='mon', minval=1,   step=5)
moneySL      = input.float  (100,             'â€‚Stop ï¼„â€‚â€‚',                group=groupset, inline='mon', minval=1,   step=5)
ATRLen       = input.int    (40,              'â€‚ATR Periodâ€‚â€‚',             group=groupset, inline='atr', minval=1,   step=1)
ATRMult      = input.float  (4,               'â€‚Multiplier',               group=groupset, inline='atr', minval=0.1, step=0.1)
trailPerc    = input.float  (3,               'â€‚Trailing ï¼…â€‚â€‚',            group=groupset, inline='trl', minval=0.1, step=0.1)
riskReward   = input.float  (2,               'â€‚R:Râ€‚â€‚â€‚â€‚1:',                group=groupset, inline='trl', minval=0.5, step=0.1)
fixedRR      = input.bool   (true,            ' Fixed RR',                 group=groupset, inline='trl', tooltip='ð…ð¢ð±ðžðâ€‚ð—¥:ð—¥â€‚âž– If the stop loss is Dynamic (Trailing or MA) then R:R can also be made Dynamic')
HHLL         = input.int    (200,             'â€‚HH / LLâ€ƒâ€‚â€‚',               group=groupset, inline='hls', minval=1,   step=5)
LoHi         = input.int    (5,               'â€‚â€‚LO / HIâ€ƒ',                group=groupset, inline='hls', minval=1,   step=1)
addPerc      = input.bool   (false,           ' Add ï¼…',                   group=groupset, inline='hls', tooltip='ð€ððâ€‚ï¼…â€‚âž– If true, then with the "ð—¦ð˜ð—¼ð—½â€‚ï¼…" parameter you can add percentages to any of the current SL. \nCan be especially useful when using Stop - ð—”ð—§ð—¥ or ð— ð—” or ð—Ÿð—¢/ð—›ð—œ. \nFor example with ð—Ÿð—¢/ð—›ð—œ to put a stop for the last High/Low and add 0.5% additional Stoploss')
maStopType   = input.string ('SMA',           'â€‚MA Stop',                  group=groupset, inline='mas', options=['ALMA', 'EMA', 'HMA', 'RMA', 'SMA', 'VWMA', 'WMA'])
maStopLen    = input.int    (15,              'â€‚Len',                      group=groupset, inline='mas', minval=1,   step=2)
maPerc       = input.float  (1.5,             'â€‚Step',                     group=groupset, inline='mas', minval=0,   step=0.1, tooltip='ðŒð€â€‚ð’ð­ð¨ð©â€‚âž– allows to choose which MA to use. \nð‹ðžð§â€‚âž– Length of chosen MA. \nð’ð­ðžð©â€‚âž–ï¼… step of change MA. Step = 0 will use the selected MA without changes. \nWARNING: When ð€ðð ï¼… is on, the MA calculation changes..')

ext_source_      = input.source (close,       'â€‚ð„ð±ð­ðžð«ð§ðšð¥â€‚ð’ð¨ð®ð«ðœðžâ€Šâ€Š',    group=groupset, inline='esrc', tooltip=TText_source_)
bullDeal         = input.bool   (true,        'â€‚Long Dealsâ€‚â€‚â€‚â€‚',      group=groupset, inline='deal')    
bearDeal         = input.bool   (true,        'â€‚Short Deals',         group=groupset, inline='deal')    
waitEndDeal      = input.bool   (true,        'â€‚Wait End Dealâ€‚',      group=groupset, inline='ord1')    
reversesignal    = input.bool   (false,       'â€‚Reverse Deals',       group=groupset, inline='ord1', tooltip=TTreversesignal)   
reEntryDeal      = input.bool   (false,       'â€‚ReEntry Dealâ€‚â€‚',      group=groupset, inline='ord2')
reOpenDeal       = input.bool   (false,       'â€‚ReOpen Deal',         group=groupset, inline='ord2', tooltip=TTreOpenDeal)


// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Risk Managment â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\ // Credit @Daveatt
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
grouprisk               = 'âž¤â€‚ï¼²ï¼©ï¼³ï¼«â€‚â€‚ï¼­ï¼¡ï¼®ï¼¡ï¼§ï¼¥ï¼­ï¼¥ï¼®ï¼´'
setmaxLosingStreak      = input.bool   (false,           '',                   group=grouprisk, inline='1')
maxLosingStreak         = input.int    (15,              'Loss Streakâ€‚â€‚â€‚',     group=grouprisk, inline='1', minval=1)
setmaxWinStreak         = input.bool   (false,           '',                   group=grouprisk, inline='1')
maxWinStreak            = input.int    (15,              'Win Streakâ€‚â€‚â€‚',      group=grouprisk, inline='1', minval=1, tooltip='ð‹ð¨ð¬ð¬â€‚ð’ð­ð«ðžðšð¤â€‚âž– Set Max number of consecutive loss trades. \nð–ð¢ð§â€‚ð’ð­ð«ðžðšð¤â€‚âž– Max Winning Streak Length.')
setmaxLosingDaysStreak  = input.bool   (false,           '',                   group=grouprisk, inline='2')
maxLosingDaysStreak     = input.int    (3,               'Row Loss InDay',     group=grouprisk, inline='2', minval=1)
setMaxDrawdown          = input.bool   (false,           '',                   group=grouprisk, inline='2')
maxPercDd               = input.int    (10,              'DrawDown ï¼…',        group=grouprisk, inline='2', minval=1, maxval=100, tooltip='ð‘ð¨ð°â€‚ð‹ð¨ð¬ð¬â€‚ðˆð§ðƒðšð²â€‚âž– Max of consecutive days with a loss in a row. \nðƒð«ðšð°ðƒð¨ð°ð§ï¼…â€‚âž– Max DrawDown (in % of strategy equity).')
setMaxIntradayLoss      = input.bool   (false,           '',                   group=grouprisk, inline='3')
maxIntradayLoss         = input.int    (3,               'InDay Loss ï¼…â€‚',     group=grouprisk, inline='3', minval=1, maxval=100)
setNumberDailyTrades    = input.bool   (false,           '',                   group=grouprisk, inline='3')
maxDailyTrades          = input.int    (10,              'Daily Tradesâ€‚â€‚',     group=grouprisk, inline='3', minval=1, maxval=100, tooltip='ðˆð§ðƒðšð²â€‚ð‹ð¨ð¬ð¬â€‚ï¼…â€‚âž– Set Max Intraday Loss. \nðƒðšð¢ð¥ð²â€‚ð“ð«ðšððžð¬â€‚âž– Limit the number of MAX trades per day.')
setNumberWeeklyTrades   = input.bool   (false,           '',                   group=grouprisk, inline='4')
maxWeeklyTrades         = input.int    (50,              'Weekly Trades',      group=grouprisk, inline='4', minval=1, maxval=100, tooltip='ð–ðžðžð¤ð¥ð²â€‚ð“ð«ðšððžð¬â€‚âž– Limit the number of MAX trades per week.')
QTYMethod               = input.string ('EQUITY',        'â€‚â€‚â€‚â€‚â€‚Order Size',    group=grouprisk, inline=' ', options=['NONE', 'EQUITY', 'SIZE', 'CONTRACTS'])
useNetProfit            = input.bool   (true,            'Use Net Profit',     group=grouprisk, inline=' ', tooltip='ð”ð¬ðžâ€‚ððžð­â€‚ðð«ð¨ðŸð¢ð­â€‚âž– On/Off the use of profit in the following trades. *Only works if the type is EQUITY')
riskPerc                = input.int    (10,              'â€‹ðŸ‡ªâ€‹â€‹ðŸ‡¶â€‹â€‹ðŸ‡ºâ€‹â€‹ðŸ‡®â€‹â€‹ðŸ‡¹â€‹â€‹ðŸ‡¾â€‹',         group=grouprisk, inline='.', minval=1, maxval=100)
riskSize                = input.int    (1000,            'â€‹ðŸ‡¸â€‹â€‹ðŸ‡®â€‹â€‹ðŸ‡¿â€‹â€‹ðŸ‡ª',            group=grouprisk, inline='.', minval=1)
riskCntr                = input.int    (1,               'â€‹ðŸ‡¨â€‹â€‹ðŸ‡´â€‹â€‹ðŸ‡³â€‹â€‹ðŸ‡¹â€‹â€‹ðŸ‡·â€‹â€‹ðŸ‡¦â€‹â€‹ðŸ‡¨â€‹â€‹ðŸ‡¹â€‹â€‹ðŸ‡¸â€‹',    group=grouprisk, inline='.', minval=1, tooltip='ðŽð«ððžð« ð’ð¢ð³ðž: \nððŽðð„â€‚âž– Use the default position size settings in Tab "Properties". \nð„ðð”ðˆð“ð˜â€‚âž– ï¼… per trade from the initial capital. \nð’ðˆð™ð„â€‚âž– Fixed size amount of trade. \nð‚ðŽðð“ð‘ð€ð‚ð“ð’â€‚âž– The fixed amount of the deal in contracts. \n')

// â€”â€”â€”â€”â€”â€” Order Size
eqty = switch QTYMethod
    'NONE'      => na
    'EQUITY'    => riskPerc / close
    'SIZE'      => riskSize / close
    'CONTRACTS' => riskCntr
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
// â€”â€”â€”â€”â€”â€” Intraday Loss ï¼…
condintradayloss = setMaxIntradayLoss ? maxIntradayLoss : 100
strategy.risk.max_intraday_loss(value=condintradayloss, type=strategy.percent_of_equity)
// â€”â€”â€”â€”â€”â€” Max Drawdown ï¼…
condmaxdrawdown = setMaxDrawdown ? maxPercDd : 100
strategy.risk.max_drawdown(value=condmaxdrawdown, type=strategy.percent_of_equity)
// â€”â€”â€”â€”â€”â€” Daily trades calculation
tradesIntradayCount = setNumberDailyTrades ? maxDailyTrades : 1000
strategy.risk.max_intraday_filled_orders(count=tradesIntradayCount)
// â€”â€”â€”â€”â€”â€” Weekly trades calculation
tradesLastWeek = 0
tradesLastWeek := dayofweek == dayofweek.monday and dayofweek != dayofweek[1] ? strategy.closedtrades[1] + strategy.opentrades[1] : tradesLastWeek[1]
// â€”â€”â€”â€”â€”â€” Calculate number of trades this week
weeklyTrades = strategy.closedtrades + strategy.opentrades - tradesLastWeek
okToTradeWeekly = setNumberWeeklyTrades ? weeklyTrades < maxWeeklyTrades : true
// â€”â€”â€”â€”â€”â€” Consecutive loss days in a row
countConsLossDays = setmaxLosingDaysStreak ? maxLosingDaysStreak : 1000
strategy.risk.max_cons_loss_days(countConsLossDays)
// â€”â€”â€”â€”â€”â€” Calculate the total losing streaks
newLoss = strategy.losstrades > strategy.losstrades[1] and strategy.wintrades == strategy.wintrades[1] and strategy.eventrades == strategy.eventrades[1]
// â€”â€”â€”â€”â€”â€” Determine current losing streak length
streakLossLen = 0
streakLossLen := newLoss ? nz(streakLossLen[1]) + 1 : strategy.wintrades > strategy.wintrades[1] or strategy.eventrades > strategy.eventrades[1] ? 0 : nz(streakLossLen[1])
// â€”â€”â€”â€”â€”â€” Check if losing streak is under max allowed
okToTradeLossStreak = setmaxLosingStreak ? streakLossLen < maxLosingStreak : true
// â€”â€”â€”â€”â€”â€” Calculate the total winning streaks
newWin = strategy.wintrades > strategy.wintrades[1] and strategy.losstrades == strategy.losstrades[1] and strategy.eventrades == strategy.eventrades[1]
// â€”â€”â€”â€”â€”â€” Figure out current winning streak length
streakWinLen = 0
streakWinLen := newWin ? nz(streakWinLen[1]) + 1 : strategy.losstrades > strategy.losstrades[1] or strategy.eventrades > strategy.eventrades[1] ? 0 : nz(streakWinLen[1])
// â€”â€”â€”â€”â€”â€” Check if winning streak is under max allowed
okToTradeWinStreak = setmaxWinStreak ? streakWinLen < maxWinStreak : true


// ***************************************************
// Risk Management
// ***************************************************

grouptakes       = 'Profit levels'
ontake1          = input.bool   (false,       'Take Profit LV 1',           group=grouptakes, inline='rw1')
qtake1           = input.int    (20,          'ï»¿',                          group=grouptakes, inline='rw1', minval=1, step=5, maxval=100) 
ontake2          = input.bool   (false,       'Take Profit LV 2',           group=grouptakes, inline='rw1')
qtake2           = input.int    (20,          'ï»¿',                          group=grouptakes, inline='rw1', minval=1, step=5, maxval=100)
ontake3          = input.bool   (false,       'Take Profit LV 3',           group=grouptakes, inline='rw2')
qtake3           = input.int    (50,          'ï»¿',                          group=grouptakes, inline='rw2', minval=1, step=5, maxval=100)
ontake4          = input.bool   (false,       'Take Profit LV 4',           group=grouptakes, inline='rw2')
qtake4           = input.int    (25,          'ï»¿',                          group=grouptakes, inline='rw2', minval=1, step=5, maxval=100)
ontake5          = input.bool   (false,       'Take Profit LV 5',           group=grouptakes, inline='take')
qtake5           = input.int    (25,          'ï»¿',                          group=grouptakes, inline='take', minval=1, step=5, maxval=100)
onstop0          = input.bool   (false,       'Stop Loss       ',           group=grouptakes, inline='take')
qstop0           = input.int    (30,          '       ï»¿',                   group=grouptakes, inline='take', minval=1, step=5, maxval=100)

bullcolor    = input.color  (#00bbd49a,     'Colors: â€‚FG',               group=grouptakes, inline='col')
bearcolor    = input.color  (#c2185c9a,     '',                          group=grouptakes, inline='col')
bullcolorb   = input.color  (#00bbd426,     'BG',                        group=grouptakes, inline='col')
bearcolorb   = input.color  (#c2185c27,     '',                          group=grouptakes, inline='col')
TipLvl       = input.string ('â€”â€”â¤´â€”â¤´â€”â¤´',     'ð“ðˆðâ€‚ð…ð¨ð«â€‚ð“ð',                group=grouptakes, inline='col', tooltip='Here you can set up intermediate Takes Profit.\nIn each line next to the TP/SL activation, you specify what % of the current position you want to close. \nFor example, if there is a checkmark next to TP 3 and its value = 50, then at this level 50ï¼… of the size of the current position will be closed.')

slNumber     = input.int    (3,               'â€‚SL 0 Position',            group=grouptakes, inline='pos', minval=1, maxval=5)
ontpBE       = input.bool   (false,           '',                          group=grouptakes, inline='pos')
tpBEnumber   = input.int    (3,               'Breakeven on TP',           group=grouptakes, inline='pos', minval=1, maxval=5, tooltip='ð’ð‹â€‚ðŸŽâ€‚ðð¨ð¬ð¢ð­ð¢ð¨ð§â€‚âž– Changes the position of the intermediate Stop Loss.\nThe value = 3 - the middle. \nðð«ðžðšð¤ðžð¯ðžð§â€‚ð¨ð§â€‚ð“ðâ€‚âž– If true Set StopLoss to Breakeven after the specified TakeProfit is reached.')
barCoolDwn   = input.int    (0,               'â€‚CoolDown # Bars',          group=grouptakes, inline='   ', minval=0, tooltip='Do Not open a new position until # bars have passed since the last trade.\nValue=0 - disables the function.')


// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
// â€”â€”â€”â€”â€”â€” Trade variables
entry        = strategy.position_avg_price
sizePos      = strategy.position_size
inLong       = sizePos > 0
inShort      = sizePos < 0
inTrade      = inLong or inShort
inPos        = (inLong and not inShort[1]) or (inShort and not inLong[1])
var ID       = 'TradeID'
var tpPrice  = float(na)
var slPrice  = float(na)

// â€”â€”â€”â€”â€”â€” Variables Initialisation
ext_source = nz(ext_source_)
bull = ext_source == +1 // +1 is bull signal
bear = ext_source == -1 // -1 is bear signal


// â€”â€”â€”â€”â€”â€” Signal
bull        := ext_source_ == close ? longEntrySignal : bull
bear        := ext_source_ == close ? shortEntrySignal : bear
bull        := reversesignal ? bear : bull
bear        := reversesignal ? bull : bear

// â€”â€”â€”â€”â€”â€” Entry solutions
direction    = 0
directionL   = bull and (nz(direction[1]) == 0 or nz(direction[1]) == -1)
directionS   = bear and (nz(direction[1]) == 0 or nz(direction[1]) == +1)
direction   := directionL ? +1 : directionS ? -1 : (reEntryDeal ? direction[1] : direction[0])
checkCoolDwn = barCoolDwn >0 ? not inTrade[barCoolDwn] : true

OkToTrade    = timeFilterApproval and okToTradeLossStreak and okToTradeWinStreak and checkCoolDwn
goLong       = ( waitEndDeal ? not inTrade and direction==+1 : direction==+1 ) and bullDeal and OkToTrade and FilterLongOK 
goShort      = ( waitEndDeal ? not inTrade and direction==-1 : direction==-1 ) and bearDeal and OkToTrade and FilterShortOK

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
DynamicStops = (slType == 'TRAILING' or slType == 'FAST TRAIL' or slType == 'ATR TRAIL' or slType == 'MA')
// â€”â€”â€”â€”â€”â€” Fixed SL/TP
if tpType == 'FIXED ï¼…'
    tpPrice := inLong and not inTrade[1] ? entry * (1 + percentTP/100) : inShort and not inTrade[1] ? entry * (1 - percentTP/100) : tpPrice
if slType == 'FIXED ï¼…'
    slPrice := inLong and not inTrade[1] ? entry * (1 - percentSL/100) : inShort and not inTrade[1] ? entry * (1 + percentSL/100) : slPrice

// â€”â€”â€”â€”â€”â€” Money SL/TP
if tpType == 'FIXED ï¼„'
    tpPrice := inLong and not inTrade[1] ? entry + (moneyTP / math.abs(sizePos)) : inShort and not inTrade[1] ? entry - (moneyTP / math.abs(sizePos)) : tpPrice
if slType == 'FIXED ï¼„'
    slPrice := inLong and not inTrade[1] ? entry - (moneySL / math.abs(sizePos)) : inShort and not inTrade[1] ? entry + (moneySL / math.abs(sizePos)) : slPrice

// â€”â€”â€”â€”â€”â€” Trailing Stop
if slType == 'TRAILING'
    StopL    = 0., StopS = 0.
    StopL   := inLong  ? math.max(close * (1 - trailPerc/100), StopL[1]) : 0
    StopS   := inShort ? math.min(close * (1 + trailPerc/100), StopS[1]) : 999999
    slPrice := inLong  ? StopL : inShort ? StopS : slPrice

// â€”â€”â€”â€”â€”â€” Fast Trailing Stop
if slType == 'FAST TRAIL'
    var stop = float(na)
    stop    := inLong and not inTrade[1] ? entry * (1 - trailPerc/100) : inShort and not inTrade[1] ? entry * (1 + trailPerc/100) : stop
    stop    := inLong and close > close[1] ? stop + (close - close[1]) : inShort and close < close[1] ? stop + (close - close[1]) : stop
    slPrice := stop

// â€”â€”â€”â€”â€”â€” ATR Fixed
StopATR      = ta.atr(ATRLen) * ATRMult
if tpType == 'ATR'
    tpPrice := inLong and not inTrade[1] ? entry + StopATR : inShort and not inTrade[1] ? entry - StopATR : tpPrice
if slType == 'ATR'
    slPrice := inLong and not inTrade[1] ? entry - StopATR : inShort and not inTrade[1] ? entry + StopATR : slPrice

// â€”â€”â€”â€”â€”â€” ATR Trail Stop
if slType == 'ATR TRAIL'
    StopL    = 0., StopS = 0.
    StopL   := inLong  ? math.max(close - StopATR, StopL[1]) : 0
    StopS   := inShort ? math.min(close + StopATR, StopS[1]) : 999999
    slPrice := inLong  ? StopL : inShort ? StopS : slPrice

// â€”â€”â€”â€”â€”â€” LO / HI Stop
if slType == 'LO / HI'
    HiStop   = ta.highest(high, LoHi)
    LoStop   = ta.lowest (low,  LoHi)
    slPrice := inLong and not inTrade[1] ? LoStop : inShort and not inTrade[1] ? HiStop : slPrice

// â€”â€”â€”â€”â€”â€” HH / LL Take
if tpType == 'HH / LL'
    HiStop   = ta.highest(high, HHLL)
    LoStop   = ta.lowest (low,  HHLL)
    tpPrice := inLong and not inTrade[1] ? HiStop : inShort and not inTrade[1] ? LoStop : tpPrice

// â€”â€”â€”â€”â€”â€” MA's Stops
if slType == 'MA'
    maSType  = MA(maStopType, close, maStopLen)
    Stop     = maSType * (maPerc / 100)
    slPrice := inLong  ? math.max(nz(slPrice[1], 0), maSType - Stop) : inShort ? math.min(nz(slPrice[1], 999999), maSType + Stop) : na

// â€”â€”â€”â€”â€”â€” Risk Reward Take
if tpType == 'R:R'
    check    = fixedRR ? not inTrade[1] : true
    tpPrice := inLong and check ? entry + (entry - slPrice) * riskReward : inShort and check ? entry - (slPrice - entry) * riskReward : tpPrice

// â€”â€”â€”â€”â€”â€” Add Percents to SL
if addPerc
    check    = DynamicStops ? true : not inTrade[1]
    slPrice := inLong and check ? slPrice * (1 - percentSL/100) : inShort and check ? slPrice * (1 + percentSL/100) : slPrice

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
// â€”â€”â€”â€”â€”â€” TPSL's
TypeStop = tpType != 'None' or slType == 'FIXED ï¼…' or slType == 'FIXED ï¼„' or slType == 'ATR' or slType == 'LO / HI'
BuildLeveles(take, nTake) => // Creating Intermediate Levels of the SL/TP - by shifting the current TP/SL to the entry level
    nTakes = 6
    var offset = float(na)
    offset := not inPos[1] ? (entry - take) : offset
    xentry = take + offset
    levels = array.new_float()
    for i = 1 to nTakes - 1
        array.push(levels, xentry + (take - xentry) * i / (nTakes))
    result = nTake >= 0 and nTake <= nTakes ? array.get(levels, nTake) : na

CheckLevels(lvl, isTake) => // Check if the SL/TP is reached 
    var float level = na
    if isTake and ((inLong and high >= lvl) or (inShort and low <= lvl))
        level := entry
    if not isTake and ((inLong and low <= lvl) or (inShort and high >= lvl))
        level := entry
    if not inTrade
        level := na
    level

// â€”â€”â€”â€”â€”â€” Get and Check Levels
stop0 = tpType != 'None' ? BuildLeveles(slPrice, slNumber-1) : slPrice , checkStop0 = TypeStop ? CheckLevels(stop0, false) : CheckLevels(stop0, true )
take1 = BuildLeveles(TypeStop ? tpPrice : slPrice, 0)                  , checkTake1 = TypeStop ? CheckLevels(take1, true ) : CheckLevels(take1, false)
take2 = BuildLeveles(TypeStop ? tpPrice : slPrice, 1)                  , checkTake2 = TypeStop ? CheckLevels(take2, true ) : CheckLevels(take2, false)
take3 = BuildLeveles(TypeStop ? tpPrice : slPrice, 2)                  , checkTake3 = TypeStop ? CheckLevels(take3, true ) : CheckLevels(take3, false)
take4 = BuildLeveles(TypeStop ? tpPrice : slPrice, 3)                  , checkTake4 = TypeStop ? CheckLevels(take4, true ) : CheckLevels(take4, false)
take5 = BuildLeveles(TypeStop ? tpPrice : slPrice, 4)                  , checkTake5 = TypeStop ? CheckLevels(take5, true ) : CheckLevels(take5, false)

// â€”â€”â€”â€”â€”â€” Move Stop to Breakeven
slbecheck = (tpBEnumber==1 and ontake1) or (tpBEnumber==2 and ontake2) or (tpBEnumber==3 and ontake3) or (tpBEnumber==4 and ontake4) or (tpBEnumber==5 and ontake5)
if ontpBE and slbecheck and not DynamicStops
    slbe     = TypeStop ? CheckLevels(BuildLeveles(tpPrice, tpBEnumber-1), true) : CheckLevels(BuildLeveles(slPrice, tpBEnumber-1), false)
    slPrice := slbe > 0 ? slbe : slPrice
    stop0   := slPrice == entry ? slPrice : stop0

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\
// â€”â€”â€”â€”â€”â€” Entry's
eqty(qty) => QTYMethod=='EQUITY' ? qty / 100 * (strategy.initial_capital + (useNetProfit ? strategy.netprofit : 0)) : QTYMethod=='SIZE' ? qty / syminfo.pointvalue : qty
if goLong 
    ID := 'Long'
    if reOpenDeal and inLong and goLong  
        strategy.close(ID, comment='reOpen')
    strategy.entry(ID, strategy.long,  qty=eqty(eqty), comment=ID, alert_message=ID + 'Entry')

if goShort
    ID := 'Short'
    if reOpenDeal and inShort and goShort
        strategy.close(ID, comment='reOpen')
    strategy.entry(ID, strategy.short, qty=eqty(eqty), comment=ID, alert_message=ID + 'Entry')

// â€”â€”â€”â€”â€”â€” Exit's
qty(perc) => math.abs(sizePos*perc/100)
if inTrade
    strategy.exit('End_0', onstop0 ? ID : 'na', qty=qty(qstop0), limit=tpPrice,                    stop=stop0,                      comment_profit='TP 0', comment_loss='SL 0', alert_message=ID + 'SL/TP 0 Trigger')
    strategy.exit('End_1', ontake1 ? ID : 'na', qty=qty(qtake1), limit=TypeStop ? take1 : tpPrice, stop=TypeStop ? slPrice : take1, comment_profit='TP 1', comment_loss='SL 1', alert_message=ID + 'SL/TP 1 Trigger')
    strategy.exit('End_2', ontake2 ? ID : 'na', qty=qty(qtake2), limit=TypeStop ? take2 : tpPrice, stop=TypeStop ? slPrice : take2, comment_profit='TP 2', comment_loss='SL 2', alert_message=ID + 'SL/TP 2 Trigger')
    strategy.exit('End_3', ontake3 ? ID : 'na', qty=qty(qtake3), limit=TypeStop ? take3 : tpPrice, stop=TypeStop ? slPrice : take3, comment_profit='TP 3', comment_loss='SL 3', alert_message=ID + 'SL/TP 3 Trigger')
    strategy.exit('End_4', ontake4 ? ID : 'na', qty=qty(qtake4), limit=TypeStop ? take4 : tpPrice, stop=TypeStop ? slPrice : take4, comment_profit='TP 4', comment_loss='SL 4', alert_message=ID + 'SL/TP 4 Trigger')
    strategy.exit('End_5', ontake5 ? ID : 'na', qty=qty(qtake5), limit=TypeStop ? take5 : tpPrice, stop=TypeStop ? slPrice : take5, comment_profit='TP 5', comment_loss='SL 5', alert_message=ID + 'SL/TP 5 Trigger')
    strategy.exit('End_6',           ID,                         limit=tpPrice,                    stop=slPrice,                    comment_profit='TP X', comment_loss='SL X', alert_message=ID + 'SL/TP X Trigger')

// ========================================================================================================================
// Plotting and Debugging
// ========================================================================================================================
plotColx = inLong ? bullcolor  : inShort ? bearcolor  : na
plotColy = inLong ? bullcolorb : inShort ? bearcolorb : na
tpcolor  = tpType != 'None' ? bullcolor : plotColx
tp = plot(inPos ? tpPrice : na, 'Take', color=tpType != 'None' ? bullcolor : plotColx, style=plot.style_linebr, editable=false)
sl = plot(inPos ? slPrice : na, 'Stop', color=tpType != 'None' ? bearcolor : plotColx, style=plot.style_linebr, editable=false)
en = plot(TypeStop ? (inLong and slPrice > entry or inShort and slPrice < entry ? slPrice : entry) : inPos ? close : na, 'Price', color=TypeStop ? #787b86 : na, style=plot.style_linebr)
fill(tp, en, color=TypeStop ? bullcolorb : plotColy, editable=false)
fill(sl, en, color=TypeStop ? bearcolorb : plotColy, editable=false)
plotchar(inPos and not inPos[1]? tpPrice : na, 'Take Start', color=tpType != 'None' ? bullcolor : plotColx, char='âž¤', location=location.absolute, size=size.tiny)
plotchar(inPos and not inPos[1]? slPrice : na, 'Stop Start', color=tpType != 'None' ? bearcolor : plotColx, char='â—‰', location=location.absolute, size=size.tiny)
plot(inPos and ontake1 and not checkTake1[1] ? take1 : na, 'TP 1', color=tpcolor,   style=plot.style_linebr, editable=false)
plot(inPos and ontake2 and not checkTake2[1] ? take2 : na, 'TP 2', color=tpcolor,   style=plot.style_linebr, editable=false)
plot(inPos and ontake3 and not checkTake3[1] ? take3 : na, 'TP 3', color=tpcolor,   style=plot.style_linebr, editable=false)
plot(inPos and ontake4 and not checkTake4[1] ? take4 : na, 'TP 4', color=tpcolor,   style=plot.style_linebr, editable=false)
plot(inPos and ontake5 and not checkTake5[1] ? take5 : na, 'TP 5', color=tpcolor,   style=plot.style_linebr, editable=false)
plot(inPos and onstop0 and not checkStop0[1] ? stop0 : na, 'SL 0', color=bearcolor, style=plot.style_linebr, editable=false)

// plot(ext_source_ == close ? ta.ema(close, 50)  : na, 'MA 1', color=#ffeb3b93, editable=false)
// plot(ext_source_ == close ? ta.ema(close, 200) : na, 'MA 2', color=#ffeb3b93, editable=false)
plotchar(goLong  and not inPos, 'goLong' , char='âœŸ', size=size.tiny, location=location.belowbar, color=#4caf4f )
plotchar(goShort and not inPos, 'goShort', char='âœŸ', size=size.tiny, location=location.abovebar, color=#ff5252 )

// Panel
var table panel = table.new(position = position.bottom_right, columns = 2, rows = 1, bgcolor = #363A45, border_width = 1)
table.cell(panel, 1, 0, text=str.tostring(0), text_color = #ffa726, bgcolor = #363A45)
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \\


// ***************************************************
// Backtest Dashboard
// ***************************************************
// Global Dashboard Variables
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘

// Dashboard Table Text Size
i_tableTextSize = input.string(title="Dashboard Size", defval="Small", options=["Auto",  "Huge",  "Large", "Normal", "Small", "Tiny"], group="Dashboards")
table_text_size(s) =>
    switch s
        "Auto"   => size.auto   
        "Huge"   => size.huge   
        "Large"  => size.large  
        "Normal" => size.normal 
        "Small"  => size.small
        => size.tiny
tableTextSize = table_text_size(i_tableTextSize)

/// Performance Summary Dashboard
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// Inspired by https://www.tradingview.com/script/uWqKX6A2/ - Thanks VertMT

i_showDashboard = input.bool(title="Performance Summary", defval=true, group="Dashboards", inline="Show Dashboards")

f_fillCell(_table, _column, _row, _title, _value, _bgcolor, _txtcolor) =>
    _cellText = _title + "\n" + _value
    table.cell(_table, _column, _row, _cellText, bgcolor=_bgcolor, text_color=_txtcolor, text_size=tableTextSize)

// Draw dashboard table
if i_showDashboard
    var bgcolor = color.new(color.black,0)
    
    // Keep track of Wins/Losses streaks
    newWin  = (strategy.wintrades  > strategy.wintrades[1]) and (strategy.losstrades == strategy.losstrades[1]) and (strategy.eventrades == strategy.eventrades[1])
    newLoss = (strategy.wintrades == strategy.wintrades[1]) and (strategy.losstrades  > strategy.losstrades[1]) and (strategy.eventrades == strategy.eventrades[1])

    varip int winRow     = 0
    varip int lossRow    = 0
    varip int maxWinRow  = 0
    varip int maxLossRow = 0

    if newWin
        lossRow := 0
        winRow := winRow + 1
    if winRow > maxWinRow
        maxWinRow := winRow
        
    if newLoss
        winRow := 0
        lossRow := lossRow + 1
    if lossRow > maxLossRow
        maxLossRow := lossRow

    // Prepare stats table
    var table dashTable = table.new(position.top_right, 1, 15, border_width=1)
   
    if barstate.islastconfirmedhistory
        // Update table
        dollarReturn = strategy.netprofit
        f_fillCell(dashTable, 0, 0, "Start:", str.format("{0,date,long}", strategy.closedtrades.entry_time(0)) , bgcolor, color.white) // + str.format(" {0,time,HH:mm}", strategy.closedtrades.entry_time(0)) 
        f_fillCell(dashTable, 0, 1, "End:", str.format("{0,date,long}", strategy.opentrades.entry_time(0)) , bgcolor, color.white) // + str.format(" {0,time,HH:mm}", strategy.opentrades.entry_time(0))
        _profit = (strategy.netprofit / strategy.initial_capital) * 100
        f_fillCell(dashTable, 0, 2, "Net Profit:", str.tostring(_profit, '##.##') + "%", _profit > 0 ? color.teal : color.maroon, color.white)
        _numOfDaysInStrategy = (strategy.opentrades.entry_time(0) - strategy.closedtrades.entry_time(0)) / (1000 * 3600 * 24)
        f_fillCell(dashTable, 0, 3, "Percent Per Day", str.tostring(_profit / _numOfDaysInStrategy, '#########################.#####')+"%", _profit > 0 ? color.teal : color.maroon, color.white)
        _winRate = ( strategy.wintrades / strategy.closedtrades ) * 100
        f_fillCell(dashTable, 0, 4, "Percent Profitable:", str.tostring(_winRate, '##.##') + "%", _winRate < 50 ? color.maroon : _winRate < 75 ? #999900 : color.teal, color.white)
        f_fillCell(dashTable, 0, 5, "Profit Factor:", str.tostring(strategy.grossprofit / strategy.grossloss,  '##.###'), strategy.grossprofit > strategy.grossloss ? color.teal : color.maroon, color.white)
        f_fillCell(dashTable, 0, 6, "Total Trades:", str.tostring(strategy.closedtrades), bgcolor, color.white)
        f_fillCell(dashTable, 0, 8, "Max Wins In A Row:", str.tostring(maxWinRow, '######') , bgcolor, color.white)
        f_fillCell(dashTable, 0, 9, "Max Losses In A Row:", str.tostring(maxLossRow, '######') , bgcolor, color.white)


// Monthly Table Performance Dashboard By @QuantNomad
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
i_showMonthlyPerformance = input.bool(true, 'Monthly Performance', group='Dashboards', inline="Show Dashboards")
i_monthlyReturnPercision = 2

if i_showMonthlyPerformance
    new_month = month(time) != month(time[1])
    new_year  = year(time)  != year(time[1])
    
    eq = strategy.equity
    
    bar_pnl = eq / eq[1] - 1
    
    cur_month_pnl = 0.0
    cur_year_pnl  = 0.0
    
    // Current Monthly P&L
    cur_month_pnl := new_month ? 0.0 : 
                     (1 + cur_month_pnl[1]) * (1 + bar_pnl) - 1 
    
    // Current Yearly P&L
    cur_year_pnl := new_year ? 0.0 : 
                     (1 + cur_year_pnl[1]) * (1 + bar_pnl) - 1  
    
    // Arrays to store Yearly and Monthly P&Ls
    var month_pnl  = array.new_float(0)
    var month_time = array.new_int(0)
    
    var year_pnl  = array.new_float(0)
    var year_time = array.new_int(0)
    
    last_computed = false
    
    if (not na(cur_month_pnl[1]) and (new_month or barstate.islastconfirmedhistory))
        if (last_computed[1])
            array.pop(month_pnl)
            array.pop(month_time)
            
        array.push(month_pnl , cur_month_pnl[1])
        array.push(month_time, time[1])
    
    if (not na(cur_year_pnl[1]) and (new_year or barstate.islastconfirmedhistory))
        if (last_computed[1])
            array.pop(year_pnl)
            array.pop(year_time)
            
        array.push(year_pnl , cur_year_pnl[1])
        array.push(year_time, time[1])
    
    last_computed := barstate.islastconfirmedhistory ? true : nz(last_computed[1])
    
    // Monthly P&L Table    
    var monthly_table = table(na)
    
    if (barstate.islastconfirmedhistory)
        monthly_table := table.new(position.bottom_right, columns = 14, rows = array.size(year_pnl) + 1, border_width = 1)
    
        table.cell(monthly_table, 0,  0, "",     bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 1,  0, "Jan",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 2,  0, "Feb",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 3,  0, "Mar",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 4,  0, "Apr",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 5,  0, "May",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 6,  0, "Jun",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 7,  0, "Jul",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 8,  0, "Aug",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 9,  0, "Sep",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 10, 0, "Oct",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 11, 0, "Nov",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 12, 0, "Dec",  bgcolor = #cccccc, text_size=tableTextSize)
        table.cell(monthly_table, 13, 0, "Year", bgcolor = #999999, text_size=tableTextSize)
    
        for yi = 0 to array.size(year_pnl) - 1
            table.cell(monthly_table, 0,  yi + 1, str.tostring(year(array.get(year_time, yi))), bgcolor = #cccccc, text_size=tableTextSize)
            
            y_color = array.get(year_pnl, yi) > 0 ? color.new(color.teal, transp = 40) : color.new(color.gray, transp = 40)
            table.cell(monthly_table, 13, yi + 1, str.tostring(math.round(array.get(year_pnl, yi) * 100, i_monthlyReturnPercision)), bgcolor = y_color, text_color=color.new(color.white, 0),text_size=tableTextSize)
            
        for mi = 0 to array.size(month_time) - 1
            m_row   = year(array.get(month_time, mi))  - year(array.get(year_time, 0)) + 1
            m_col   = month(array.get(month_time, mi)) 
            m_color = array.get(month_pnl, mi) > 0 ? color.new(color.teal, transp = 40) : color.new(color.maroon, transp = 40)
            
            table.cell(monthly_table, m_col, m_row, str.tostring(math.round(array.get(month_pnl, mi) * 100, i_monthlyReturnPercision)), bgcolor = m_color, text_color=color.new(color.white, 0), text_size=tableTextSize)



